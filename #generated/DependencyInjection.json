[
  {
    "name": "Autofac",
    "url": "http://autofac.org",
    "version": "3.5.0.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81",
      "wpa81",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "success"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "success"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "failure",
        "comment": "Autofac.Core.DependencyResolutionException: None of the constructors found with 'Autofac.Core.Activators.Reflection.DefaultConstructorFinder' on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency' can be invoked with the available services and parameters:\r\nCannot resolve parameter 'FeatureTests.On.DependencyInjection.TestTypes.IService service' of constructor 'Void .ctor(FeatureTests.On.DependencyInjection.TestTypes.IService)'.\r\n   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Execute()\r\n   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.ResolveComponent(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Activators.Reflection.AutowiringParameter.<>c__DisplayClass2.<CanSupplyValue>b__0()\r\n   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()\r\n   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Execute()\r\n   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Lifetime.LifetimeScope.ResolveComponent(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at lambda_method(Closure , IService )\r\n",
        "error": "Autofac.Core.DependencyResolutionException: None of the constructors found with 'Autofac.Core.Activators.Reflection.DefaultConstructorFinder' on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency' can be invoked with the available services and parameters:\r\nCannot resolve parameter 'FeatureTests.On.DependencyInjection.TestTypes.IService service' of constructor 'Void .ctor(FeatureTests.On.DependencyInjection.TestTypes.IService)'.\r\n   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Execute()\r\n   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.ResolveComponent(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Activators.Reflection.AutowiringParameter.<>c__DisplayClass2.<CanSupplyValue>b__0()\r\n   at Autofac.Core.Activators.Reflection.ConstructorParameterBinding.Instantiate()\r\n   at Autofac.Core.Activators.Reflection.ReflectionActivator.ActivateInstance(IComponentContext context, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Activate(IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.InstanceLookup.Execute()\r\n   at Autofac.Core.Resolving.ResolveOperation.GetOrCreateInstance(ISharingLifetimeScope currentOperationScope, IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Resolving.ResolveOperation.Execute(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at Autofac.Core.Lifetime.LifetimeScope.ResolveComponent(IComponentRegistration registration, IEnumerable`1 parameters)\r\n   at lambda_method(Closure , IService )\r\n"
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotSameException: Assert.NotSame() Failure\r\n   at Xunit.Assert.NotSame(Object expected, Object actual)\r\n",
        "error": "Xunit.Sdk.NotSameException: Assert.NotSame() Failure\r\n   at Xunit.Assert.NotSame(Object expected, Object actual)\r\n"
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: Autofac fails list recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: Autofac fails list recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      }
    }
  },
  {
    "name": "Castle",
    "url": "http://docs.castleproject.org/Windsor.MainPage.ashx",
    "version": "3.3.0.0",
    "supports": [
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "success"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "success"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "failure",
        "comment": "Castle.MicroKernel.Resolvers.DependencyResolverException: Missing dependency.\r\nComponent FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency has a dependency on FeatureTests.On.DependencyInjection.TestTypes.IService, which could not be resolved.\r\nMake sure the dependency is correctly registered in the container as a service, or provided as inline argument. ---> Castle.MicroKernel.Handlers.HandlerException: Handler for FeatureTests.On.DependencyInjection.TestTypes.IService was not found.\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.TryGetHandlerFromKernel(DependencyModel dependency, CreationContext context)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   --- End of inner exception stack trace ---\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveCore(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.CreateConstructorArguments(ConstructorCandidate constructor, CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.Instantiate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.InternalCreate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.Create(CreationContext context, Burden burden)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.CreateInstance(CreationContext context, Boolean trackedExternally)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Resolve(CreationContext context, IReleasePolicy releasePolicy)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(CreationContext context, Boolean requiresDecommission, Boolean instanceRequired, Burden& burden)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.Resolve(CreationContext context, Boolean instanceRequired)\r\n   at Castle.MicroKernel.Handlers.AbstractHandler.Resolve(CreationContext context)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveCore(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.CreateConstructorArguments(ConstructorCandidate constructor, CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.Instantiate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.InternalCreate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.Create(CreationContext context, Burden burden)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.CreateInstance(CreationContext context, Boolean trackedExternally)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Resolve(CreationContext context, IReleasePolicy releasePolicy)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(CreationContext context, Boolean requiresDecommission, Boolean instanceRequired, Burden& burden)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.Resolve(CreationContext context, Boolean instanceRequired)\r\n   at Castle.MicroKernel.Handlers.AbstractHandler.Resolve(CreationContext context)\r\n   at Castle.MicroKernel.DefaultKernel.ResolveComponent(IHandler handler, Type service, IDictionary additionalArguments, IReleasePolicy policy)\r\n   at Castle.MicroKernel.DefaultKernel.Castle.MicroKernel.IKernelInternal.Resolve(Type service, IDictionary arguments, IReleasePolicy policy)\r\n   at Castle.Facilities.TypedFactory.TypedFactoryComponentResolver.Resolve(IKernelInternal kernel, IReleasePolicy scope)\r\n   at Castle.Facilities.TypedFactory.Internal.TypedFactoryInterceptor.Resolve(IInvocation invocation)\r\n   at Castle.Facilities.TypedFactory.Internal.TypedFactoryInterceptor.Intercept(IInvocation invocation)\r\n   at Castle.DynamicProxy.AbstractInvocation.Proceed()\r\n   at Castle.Proxies.Func`2Proxy.Invoke(IService arg)\r\n",
        "error": "Castle.MicroKernel.Resolvers.DependencyResolverException: Missing dependency.\r\nComponent FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency has a dependency on FeatureTests.On.DependencyInjection.TestTypes.IService, which could not be resolved.\r\nMake sure the dependency is correctly registered in the container as a service, or provided as inline argument. ---> Castle.MicroKernel.Handlers.HandlerException: Handler for FeatureTests.On.DependencyInjection.TestTypes.IService was not found.\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.TryGetHandlerFromKernel(DependencyModel dependency, CreationContext context)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   --- End of inner exception stack trace ---\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveCore(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.CreateConstructorArguments(ConstructorCandidate constructor, CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.Instantiate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.InternalCreate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.Create(CreationContext context, Burden burden)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.CreateInstance(CreationContext context, Boolean trackedExternally)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Resolve(CreationContext context, IReleasePolicy releasePolicy)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(CreationContext context, Boolean requiresDecommission, Boolean instanceRequired, Burden& burden)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.Resolve(CreationContext context, Boolean instanceRequired)\r\n   at Castle.MicroKernel.Handlers.AbstractHandler.Resolve(CreationContext context)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernelByType(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveFromKernel(CreationContext context, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.ResolveCore(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.Resolvers.DefaultDependencyResolver.Resolve(CreationContext context, ISubDependencyResolver contextHandlerResolver, ComponentModel model, DependencyModel dependency)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.CreateConstructorArguments(ConstructorCandidate constructor, CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.Instantiate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.DefaultComponentActivator.InternalCreate(CreationContext context)\r\n   at Castle.MicroKernel.ComponentActivator.AbstractComponentActivator.Create(CreationContext context, Burden burden)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.CreateInstance(CreationContext context, Boolean trackedExternally)\r\n   at Castle.MicroKernel.Lifestyle.AbstractLifestyleManager.Resolve(CreationContext context, IReleasePolicy releasePolicy)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.ResolveCore(CreationContext context, Boolean requiresDecommission, Boolean instanceRequired, Burden& burden)\r\n   at Castle.MicroKernel.Handlers.DefaultHandler.Resolve(CreationContext context, Boolean instanceRequired)\r\n   at Castle.MicroKernel.Handlers.AbstractHandler.Resolve(CreationContext context)\r\n   at Castle.MicroKernel.DefaultKernel.ResolveComponent(IHandler handler, Type service, IDictionary additionalArguments, IReleasePolicy policy)\r\n   at Castle.MicroKernel.DefaultKernel.Castle.MicroKernel.IKernelInternal.Resolve(Type service, IDictionary arguments, IReleasePolicy policy)\r\n   at Castle.Facilities.TypedFactory.TypedFactoryComponentResolver.Resolve(IKernelInternal kernel, IReleasePolicy scope)\r\n   at Castle.Facilities.TypedFactory.Internal.TypedFactoryInterceptor.Resolve(IInvocation invocation)\r\n   at Castle.Facilities.TypedFactory.Internal.TypedFactoryInterceptor.Intercept(IInvocation invocation)\r\n   at Castle.DynamicProxy.AbstractInvocation.Proceed()\r\n   at Castle.Proxies.Func`2Proxy.Invoke(IService arg)\r\n"
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "success"
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "Catel",
    "url": "http://www.catelproject.com",
    "version": "4.0.0.0",
    "supports": [
      "MonoAndroid",
      "MonoTouch",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81",
      "wpa81",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[FeatureTests.On.DependencyInjection.TestTypes.IService[], FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[FeatureTests.On.DependencyInjection.TestTypes.IService[], FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n",
        "error": "Catel.IoC.TypeNotRegisteredException: The specified type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is not registered or could not be constructed. Please register type before using it. Failed to instantiate the type using the TypeFactory. Check if the required dependencies are registered as well or that the type has a valid constructor that can be used.\r\n   at Catel.IoC.ServiceLocator.ThrowTypeNotRegisteredException(Type type, String message)\r\n   at Catel.IoC.ServiceLocator.CreateServiceInstance(ServiceLocatorRegistration registration)\r\n   at Catel.IoC.ServiceLocator.<>c__DisplayClass12.<RegisterType>b__10(ServiceLocatorRegistration x)\r\n   at Catel.IoC.ServiceLocator.ResolveTypeFromKnownContainer(Type serviceType, Object tag)\r\n   at Catel.IoC.ServiceLocator.ResolveType(Type serviceType, Object tag)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n",
        "error": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if Catel can allow PerRequest lifetime.\r\n",
        "error": "System.NotSupportedException: I am not sure if Catel can allow PerRequest lifetime.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "Dynamo.Ioc",
    "url": "http://martinf.github.io/Dynamo-IoC",
    "version": "3.0.2.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "OpenGenericTypes": {
        "result": "failure",
        "comment": "System.ArgumentException: Type: IGenericService`1 is not assignable from implementation type: GenericService`1\r\n   at Dynamo.Ioc.IocContainer.Register(Type type, Type implType, Object key, ILifetime lifetime, Nullable`1 compileMode, Boolean includeInternalCtor, Func`2 selector)\r\n",
        "error": "System.ArgumentException: Type: IGenericService`1 is not assignable from implementation type: GenericService`1\r\n   at Dynamo.Ioc.IocContainer.Register(Type type, Type implType, Object key, ILifetime lifetime, Nullable`1 compileMode, Boolean includeInternalCtor, Func`2 selector)\r\n"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if Dynamo.Ioc provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n",
        "error": "System.NotSupportedException: I am not sure if Dynamo.Ioc provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at Dynamo.Ioc.Index.DirectIndex.Get(Type type)\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n   at lambda_method(Closure , IResolver )\r\n   at Dynamo.Ioc.ExpressionRegistration`1.CreateInstance()\r\n   at Dynamo.Ioc.TransientLifetime.GetInstance(IInstanceFactoryRegistration registration)\r\n   at Dynamo.Ioc.ExpressionRegistration`1.GetInstance()\r\n   at Dynamo.Ioc.IocContainer.Resolve(Type type)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: Dynamo.Ioc fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: Dynamo.Ioc fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "Grace",
    "url": "https://github.com/ipjohnson/Grace",
    "version": "2.4.2.0",
    "supports": [
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81",
      "wpa81"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "success"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "success"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "success"
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "success"
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Grace.DependencyInjection.Exceptions.MissingDependencyException: Could not locate IUnregisteredService for parameter service2 on ServiceWithMultipleConstructors\r\n\r\n1 Locate by type ServiceWithMultipleConstructors in scope 'RootScope' \r\n2 Activating type ServiceWithMultipleConstructors  as transient\r\n3 Importing  constructor parameter service2 using type IUnregisteredService\r\n\r\n   at lambda_method(Closure , IInjectionScope , IInjectionContext )\r\n   at Grace.DependencyInjection.Impl.CompiledExportStrategy.Activate(IInjectionScope exportInjectionScope, IInjectionContext context, ExportStrategyFilter consider, Object locateKey)\r\n   at Grace.DependencyInjection.Impl.ExportStrategyCollection.Activate(String exportName, TypeWrapper exportType, IInjectionContext injectionContext, ExportStrategyFilter filter, Object locateKey)\r\n   at Grace.DependencyInjection.Impl.InjectionKernel.Locate(Type objectType, IInjectionContext injectionContext, ExportStrategyFilter consider, Object locateKey)\r\n   at Grace.DependencyInjection.DependencyInjectionContainer.Locate(Type objectType, IInjectionContext injectionContext, ExportStrategyFilter consider, Object withKey)\r\n",
        "error": "Grace.DependencyInjection.Exceptions.MissingDependencyException: Could not locate IUnregisteredService for parameter service2 on ServiceWithMultipleConstructors\r\n\r\n1 Locate by type ServiceWithMultipleConstructors in scope 'RootScope' \r\n2 Activating type ServiceWithMultipleConstructors  as transient\r\n3 Importing  constructor parameter service2 using type IUnregisteredService\r\n\r\n   at lambda_method(Closure , IInjectionScope , IInjectionContext )\r\n   at Grace.DependencyInjection.Impl.CompiledExportStrategy.Activate(IInjectionScope exportInjectionScope, IInjectionContext context, ExportStrategyFilter consider, Object locateKey)\r\n   at Grace.DependencyInjection.Impl.ExportStrategyCollection.Activate(String exportName, TypeWrapper exportType, IInjectionContext injectionContext, ExportStrategyFilter filter, Object locateKey)\r\n   at Grace.DependencyInjection.Impl.InjectionKernel.Locate(Type objectType, IInjectionContext injectionContext, ExportStrategyFilter consider, Object locateKey)\r\n   at Grace.DependencyInjection.DependencyInjectionContainer.Locate(Type objectType, IInjectionContext injectionContext, ExportStrategyFilter consider, Object withKey)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "HaveBox",
    "url": "http://www.havebox.net/",
    "version": "2.0.0.0",
    "supports": [
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "wp71",
      "wp80",
      "wp81",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: IService[]\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: IService[]\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: IList`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: IList`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: ICollection`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: ICollection`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: IReadOnlyCollection`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: IReadOnlyCollection`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: IReadOnlyList`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: IReadOnlyList`1\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at HaveBox.Container.CreateClosedGenericTypeAndRegister(Config config, Type type, TypeDetails openGenericType)\r\n   at HaveBox.Container.<>c__DisplayClass8.<TryResolveGenericTypeTree>b__7(TypeDetails openGenericType)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at HaveBox.Container.CreateClosedGenericTypeAndRegister(Config config, Type type, TypeDetails openGenericType)\r\n   at HaveBox.Container.<>c__DisplayClass8.<TryResolveGenericTypeTree>b__7(TypeDetails openGenericType)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nParameter name: Unkown key: System.Func`1[TResult]\r\n   at HaveBox.Collections.Generic.HashTable`2.get_Item(TKey key)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n",
        "error": "System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nParameter name: Unkown key: System.Func`1[TResult]\r\n   at HaveBox.Collections.Generic.HashTable`2.get_Item(TKey key)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nParameter name: Unkown key: System.Lazy`1[T]\r\n   at HaveBox.Collections.Generic.HashTable`2.get_Item(TKey key)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n",
        "error": "System.ArgumentOutOfRangeException: Specified argument was out of the range of valid values.\r\nParameter name: Unkown key: System.Lazy`1[T]\r\n   at HaveBox.Collections.Generic.HashTable`2.get_Item(TKey key)\r\n   at HaveBox.Container.TryResolveGenericTypeTree(Config config, Type type)\r\n   at HaveBox.Container.TryResolveGenericType(Type type)\r\n   at HaveBox.Container.GetInstance(Type type)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if HaveBox can allow PerRequest lifetime.\r\n",
        "error": "System.NotSupportedException: I am not sure if HaveBox can allow PerRequest lifetime.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "System.NotSupportedException: Resolving for multiple ServiceWithMultipleConstructors constructors, is not supported\r\n   at HaveBox.Configuration.InjectionExpression.CheckForMoreThanOneConstructorOnType(Type type)\r\n   at HaveBox.Configuration.InjectionExpression.Use(Type type)\r\n",
        "error": "System.NotSupportedException: Resolving for multiple ServiceWithMultipleConstructors constructors, is not supported\r\n   at HaveBox.Configuration.InjectionExpression.CheckForMoreThanOneConstructorOnType(Type type)\r\n   at HaveBox.Configuration.InjectionExpression.Use(Type type)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "System.Exception: Unknown type: ServiceWithRecursiveDependency2\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n",
        "error": "System.Exception: Unknown type: ServiceWithRecursiveDependency2\r\n   at HaveBox.DependencyStrapper.ResolveTypeDetailsList(IDictionary`2 dependencyMap, Type type)\r\n   at HaveBox.DependencyStrapper.GetParameterTypeDetails(IDictionary`2 dependencyMap, ParameterInfo parameterInfo)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass7.<DependencyCreateInstanceResolver>b__6(ParameterInfo x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.DependencyCreateInstanceResolver(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstanceDelegate(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.GetCreateInstance(TypeDetails typeDetails, IDictionary`2 dependencyMap)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__2(TypeDetails z)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.<>c__DisplayClass3.<Strap>b__0(KeyValuePair`2 x)\r\n   at HaveBox.IEnumerableExtensions.Each[T](IEnumerable`1 enumeration, Action`1 action)\r\n   at HaveBox.DependencyStrapper.Strap(IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.StrapAndMarkSingletons(Guid containerId, IDictionary`2 dependencyMap)\r\n   at HaveBox.Container.Configure(Action`1 registry)\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "IfInjector",
    "url": "https://github.com/iamahern/IfInjector",
    "version": "0.8.1.42024",
    "supports": [
      "net45",
      "net451",
      "win",
      "win81",
      "wp71",
      "wp80",
      "wp81",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'System.Int32', on 'IfInjector.Resolver.Resolver`1[CType] CreateResolverInstanceGeneric[BType,CType](IfInjector.Bindings.Config.BindingKey, IfInjector.Bindings.Config.IBindingConfig, Boolean)' violates the constraint of type 'BType'. ---> System.Security.VerificationException: Method IfInjector.Injector.CreateResolverInstanceGeneric: type argument 'System.Int32' violates the constraint of type parameter 'BType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   at IfInjector.Injector.CreateResolverInstance(BindingKey bindingKey, Type implType, IBindingConfig bindingConfig, Boolean isImplicitBinding)\r\n   at IfInjector.Injector.BindImplicit(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolver(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'System.Int32', on 'IfInjector.Resolver.Resolver`1[CType] CreateResolverInstanceGeneric[BType,CType](IfInjector.Bindings.Config.BindingKey, IfInjector.Bindings.Config.IBindingConfig, Boolean)' violates the constraint of type 'BType'. ---> System.Security.VerificationException: Method IfInjector.Injector.CreateResolverInstanceGeneric: type argument 'System.Int32' violates the constraint of type parameter 'BType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   at IfInjector.Injector.CreateResolverInstance(BindingKey bindingKey, Type implType, IBindingConfig bindingConfig, Boolean isImplicitBinding)\r\n   at IfInjector.Injector.BindImplicit(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolver(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "OpenGenericTypes": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]', on 'IfInjector.Bindings.Fluent.Concrete.IBinding`2[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[T],CType] To[CType]()' violates the constraint of type 'CType'. ---> System.Security.VerificationException: Method IfInjector.Bindings.Fluent.Concrete.IOngoingBinding`1[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[T]].To: type argument 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]' violates the constraint of type parameter 'CType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]', on 'IfInjector.Bindings.Fluent.Concrete.IBinding`2[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[T],CType] To[CType]()' violates the constraint of type 'CType'. ---> System.Security.VerificationException: Method IfInjector.Bindings.Fluent.Concrete.IOngoingBinding`1[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[T]].To: type argument 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]' violates the constraint of type parameter 'CType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'System.IntPtr', on 'IfInjector.Resolver.Resolver`1[CType] CreateResolverInstanceGeneric[BType,CType](IfInjector.Bindings.Config.BindingKey, IfInjector.Bindings.Config.IBindingConfig, Boolean)' violates the constraint of type 'BType'. ---> System.Security.VerificationException: Method IfInjector.Injector.CreateResolverInstanceGeneric: type argument 'System.IntPtr' violates the constraint of type parameter 'BType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   at IfInjector.Injector.CreateResolverInstance(BindingKey bindingKey, Type implType, IBindingConfig bindingConfig, Boolean isImplicitBinding)\r\n   at IfInjector.Injector.BindImplicit(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolver(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'System.IntPtr', on 'IfInjector.Resolver.Resolver`1[CType] CreateResolverInstanceGeneric[BType,CType](IfInjector.Bindings.Config.BindingKey, IfInjector.Bindings.Config.IBindingConfig, Boolean)' violates the constraint of type 'BType'. ---> System.Security.VerificationException: Method IfInjector.Injector.CreateResolverInstanceGeneric: type argument 'System.IntPtr' violates the constraint of type parameter 'BType'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   at IfInjector.Injector.CreateResolverInstance(BindingKey bindingKey, Type implType, IBindingConfig bindingConfig, Boolean isImplicitBinding)\r\n   at IfInjector.Injector.BindImplicit(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolver(BindingKey bindingKey)\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileArgumentListExprs(IEnumerable`1 args)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n",
        "error": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Error on FeatureTests.On.DependencyInjection.TestTypes.IService. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetSetterValueExpression[MIType](IMemberSetterConfig`1 setter)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.<CompileConstructorExpr>b__4(IMemberSetterConfig`1 iconf)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.<UnionIterator>d__88`1.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n",
        "error": "IfInjector.Errors.InjectorException: Error on FeatureTests.On.DependencyInjection.TestTypes.IService. Unable to resolve Interface and Abstract classes without a configuration.\r\n   at IfInjector.Bindings.Config.BindingConfigUtils.ThrowInterfaceException[CType]()\r\n   at lambda_method(Closure )\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.GetResolveExpression()\r\n   at IfInjector.Injector.ResolveResolverExpression(BindingKey bindingKey)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetResolverInvocationExpressionForType(Type parameterType)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.GetSetterValueExpression[MIType](IMemberSetterConfig`1 setter)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.<CompileConstructorExpr>b__4(IMemberSetterConfig`1 iconf)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.<UnionIterator>d__88`1.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileConstructorExpr()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.CompileResolverExpression()\r\n   at IfInjector.Resolver.Expressions.ExpressionCompiler`1.get_InstanceResolver()\r\n   at IfInjector.Resolver.Resolver`1.CompileResolver()\r\n   at IfInjector.Resolver.Resolver`1.DoResolve()\r\n   at IfInjector.Injector.Resolve(Type type)\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if IfInjector provides PerRequest lifetime out of the box.\r\n",
        "error": "System.NotSupportedException: I am not sure if IfInjector provides PerRequest lifetime out of the box.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n",
        "error": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "failure",
        "comment": "IfInjector.Errors.InjectorException: Injector is in resolved state. Explicit binding registration is no longer permitted.\r\n   at IfInjector.Injector.ValidateInternalBinding(IBindingInternal internalBinding)\r\n   at IfInjector.Injector.Register(IBinding binding)\r\n   at lambda_method(Closure )\r\n",
        "error": "IfInjector.Errors.InjectorException: Injector is in resolved state. Explicit binding registration is no longer permitted.\r\n   at IfInjector.Injector.ValidateInternalBinding(IBindingInternal internalBinding)\r\n   at IfInjector.Injector.Register(IBinding binding)\r\n   at lambda_method(Closure )\r\n"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "LightCore",
    "url": "http://lightcore.ch/en/default.aspx",
    "version": "1.5.1.0",
    "supports": [
      "net35",
      "net35-cf",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "sl30",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.ArgumentException: Object of type 'System.Object[]' cannot be converted to type 'FeatureTests.On.DependencyInjection.TestTypes.IService[]'.\r\n   at System.RuntimeType.TryChangeType(Object value, Binder binder, CultureInfo culture, Boolean needsSpecialCast)\r\n   at System.RuntimeType.CheckValue(Object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr)\r\n   at System.Reflection.MethodBase.CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig)\r\n   at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve(Type contractType)\r\n",
        "error": "System.ArgumentException: Object of type 'System.Object[]' cannot be converted to type 'FeatureTests.On.DependencyInjection.TestTypes.IService[]'.\r\n   at System.RuntimeType.TryChangeType(Object value, Binder binder, CultureInfo culture, Boolean needsSpecialCast)\r\n   at System.RuntimeType.CheckValue(Object value, Binder binder, CultureInfo culture, BindingFlags invokeAttr)\r\n   at System.Reflection.MethodBase.CheckArguments(Object[] parameters, Binder binder, BindingFlags invokeAttr, CultureInfo culture, Signature sig)\r\n   at System.Reflection.RuntimeConstructorInfo.Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture)\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve(Type contractType)\r\n"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nExpected: 1\r\nActual:   0\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n",
        "error": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nExpected: 1\r\nActual:   0\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "success"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "failure",
        "comment": "LightCore.ResolutionFailedException: Exception of type 'LightCore.ResolutionFailedException' was thrown.\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve(Type contractType)\r\n   at LightCore.Activation.Components.ArgumentCollector.CollectArguments(Func`2 dependencyResolver, ParameterInfo[] parameters, ResolutionContext resolutionContext)\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve[TContract](IEnumerable`1 arguments)\r\n   at lambda_method(Closure , IService )\r\n",
        "error": "LightCore.ResolutionFailedException: Exception of type 'LightCore.ResolutionFailedException' was thrown.\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve(Type contractType)\r\n   at LightCore.Activation.Components.ArgumentCollector.CollectArguments(Func`2 dependencyResolver, ParameterInfo[] parameters, ResolutionContext resolutionContext)\r\n   at LightCore.Activation.Activators.ReflectionActivator.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Registration.RegistrationItem.<>c__DisplayClass1.<ActivateInstance>b__0()\r\n   at LightCore.Lifecycle.TransientLifecycle.ReceiveInstanceInLifecycle(Func`1 newInstanceResolver)\r\n   at LightCore.Registration.RegistrationItem.ActivateInstance(ResolutionContext resolutionContext)\r\n   at LightCore.Container.Resolve(RegistrationItem registrationItem)\r\n   at LightCore.Container.ResolveInternal(Type contractType, IEnumerable`1 arguments, IDictionary`2 namedArguments)\r\n   at LightCore.Container.Resolve[TContract](IEnumerable`1 arguments)\r\n   at lambda_method(Closure , IService )\r\n"
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if LightCore provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n",
        "error": "System.NotSupportedException: I am not sure if LightCore provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "failure",
        "comment": "System.NullReferenceException: Object reference not set to an instance of an object.\r\n",
        "error": "System.NullReferenceException: Object reference not set to an instance of an object.\r\n"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: LightCore fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: LightCore fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "LightInject",
    "url": "http://www.lightinject.net/",
    "version": "3.0.2.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "success"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "failure",
        "comment": "System.InvalidOperationException: Unable to resolve type: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies, service name:  ---> System.InvalidOperationException: Unresolved dependency [Target Type: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], [Parameter: service2(FeatureTests.On.DependencyInjection.TestTypes.IService2)], [Requested dependency: ServiceType:FeatureTests.On.DependencyInjection.TestTypes.IService2, ServiceName:]\r\n   at LightInject.ServiceContainer.GetEmitMethodForDependency(Dependency dependency)\r\n   at LightInject.ServiceContainer.EmitConstructorDependency(IEmitter emitter, Dependency dependency)\r\n   at LightInject.ServiceContainer.EmitConstructorDependencies(ConstructionInfo constructionInfo, IEmitter emitter, Action`1 decoratorTargetEmitter)\r\n   at LightInject.ServiceContainer.EmitNewInstanceUsingImplementingType(IEmitter emitter, ConstructionInfo constructionInfo, Action`1 decoratorTargetEmitMethod)\r\n   at LightInject.ServiceContainer.EmitNewInstance(ServiceRegistration serviceRegistration, IEmitter emitter)\r\n   at LightInject.ServiceContainer.EmitNewInstanceWithDecorators(ServiceRegistration serviceRegistration, IEmitter emitter)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass83.<ResolveEmitMethod>b__7f(IEmitter methodSkeleton)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass30.<CreateEmitMethodWrapper>b__2f(IEmitter ms)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass30.<CreateEmitMethodWrapper>b__2f(IEmitter ms)\r\n   at LightInject.ServiceContainer.CreateDynamicMethodDelegate(Action`1 serviceEmitter)\r\n   at LightInject.ServiceContainer.CreateDelegate(Type serviceType, String serviceName, Boolean throwError)\r\n   --- End of inner exception stack trace ---\r\n   at LightInject.ServiceContainer.CreateDelegate(Type serviceType, String serviceName, Boolean throwError)\r\n   at LightInject.ServiceContainer.CreateDefaultDelegate(Type serviceType, Boolean throwError)\r\n   at LightInject.ServiceContainer.GetInstance(Type serviceType, Object[] arguments)\r\n   at LightInject.ServiceContainer.GetInstance[T,TService](T value)\r\n",
        "error": "System.InvalidOperationException: Unable to resolve type: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies, service name:  ---> System.InvalidOperationException: Unresolved dependency [Target Type: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], [Parameter: service2(FeatureTests.On.DependencyInjection.TestTypes.IService2)], [Requested dependency: ServiceType:FeatureTests.On.DependencyInjection.TestTypes.IService2, ServiceName:]\r\n   at LightInject.ServiceContainer.GetEmitMethodForDependency(Dependency dependency)\r\n   at LightInject.ServiceContainer.EmitConstructorDependency(IEmitter emitter, Dependency dependency)\r\n   at LightInject.ServiceContainer.EmitConstructorDependencies(ConstructionInfo constructionInfo, IEmitter emitter, Action`1 decoratorTargetEmitter)\r\n   at LightInject.ServiceContainer.EmitNewInstanceUsingImplementingType(IEmitter emitter, ConstructionInfo constructionInfo, Action`1 decoratorTargetEmitMethod)\r\n   at LightInject.ServiceContainer.EmitNewInstance(ServiceRegistration serviceRegistration, IEmitter emitter)\r\n   at LightInject.ServiceContainer.EmitNewInstanceWithDecorators(ServiceRegistration serviceRegistration, IEmitter emitter)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass83.<ResolveEmitMethod>b__7f(IEmitter methodSkeleton)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass30.<CreateEmitMethodWrapper>b__2f(IEmitter ms)\r\n   at LightInject.ServiceContainer.<>c__DisplayClass30.<CreateEmitMethodWrapper>b__2f(IEmitter ms)\r\n   at LightInject.ServiceContainer.CreateDynamicMethodDelegate(Action`1 serviceEmitter)\r\n   at LightInject.ServiceContainer.CreateDelegate(Type serviceType, String serviceName, Boolean throwError)\r\n   --- End of inner exception stack trace ---\r\n   at LightInject.ServiceContainer.CreateDelegate(Type serviceType, String serviceName, Boolean throwError)\r\n   at LightInject.ServiceContainer.CreateDefaultDelegate(Type serviceType, Boolean throwError)\r\n   at LightInject.ServiceContainer.GetInstance(Type serviceType, Object[] arguments)\r\n   at LightInject.ServiceContainer.GetInstance[T,TService](T value)\r\n"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "success"
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "LinFu",
    "url": "https://github.com/philiplaureano/LinFu",
    "version": "2.3.0.41559",
    "supports": [
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "failure",
        "comment": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "System.MissingMethodException: Constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' not found.\r\n   at System.RuntimeType.CreateInstanceImpl(BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes, StackCrawlMark& stackMark)\r\n   at System.Activator.CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes)\r\n   at System.Activator.CreateInstance(Type type, Object[] args)\r\n   at LinFu.IoC.Configuration.ConstructorInvoke.Invoke(Object target, ConstructorInfo targetMethod, Object[] arguments)\r\n   at LinFu.IoC.Configuration.DefaultActivator.CreateInstance(IContainerActivationContext context)\r\n   at LinFu.IoC.ContainerExtensions.AutoCreateInternal(IServiceContainer container, Type concreteType, Object[] additionalArguments)\r\n   at LinFu.IoC.Configuration.FactoryBuilder.<CreateFactoryMethodInternal>b__4[TService,TImplementation](IFactoryRequest request)\r\n   at LinFu.IoC.Factories.OncePerRequestFactory`1.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.Factories.BaseFactory`1.LinFu.IoC.Interfaces.IFactory.CreateInstance(IFactoryRequest request)\r\n   at LinFu.IoC.DefaultCreator.CreateFrom(IFactoryRequest factoryRequest, IFactory factory)\r\n   at LinFu.IoC.DefaultGetServiceBehavior.GetService(IServiceRequest serviceRequest)\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[[FeatureTests.On.DependencyInjection.TestTypes.IndependentService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IGenericService`1[[FeatureTests.On.DependencyInjection.TestTypes.IndependentService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Func`1[[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Func`1[[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Lazy`1[[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n",
        "error": "LinFu.IoC.ServiceNotFoundException: Service type 'System.Lazy`1[[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089' not found\r\n   at LinFu.IoC.ServiceContainer.GetService(String serviceName, Type serviceType, Object[] additionalArguments)\r\n   at LinFu.IoC.ServiceContainer.GetService(Type serviceType, Object[] additionalArguments)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if LinFu provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n",
        "error": "System.NotSupportedException: I am not sure if LinFu provides PerRequest lifetime out of the box.\r\nIt does provide PerThread, but a web request is not guaranteed to stay in one thread.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "MEF",
    "version": "4.0.0.0",
    "supports": [],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.ICollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyCollection(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.CompositionException: The composition produced a single composition error. The root cause is provided below. Review the CompositionException.Errors property for more detailed information.\r\n\r\n1) The importing constructor on type 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]]' is using ImportManyAttribute on parameter 'services' with a non-assignable type. On constructor parameters the ImportManyAttribute only supports importing into types T[] or IEnumerable<T>.\r\n\r\nResulting in: Cannot activate part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\nResulting in: Cannot get export 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))\")' from part 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))'.\r\nElement: FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) (ContractName=\"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))\") -->  FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService)) -->  TypeCatalog (Types='FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency(System.Collections.Generic.IReadOnlyList(FeatureTests.On.DependencyInjection.TestTypes.IService))').\r\n\r\n   at System.ComponentModel.Composition.Hosting.CompositionServices.GetExportedValueFromComposedPart(ImportEngine engine, ComposablePart part, ExportDefinition definition)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.GetExportedValue(CatalogPart part, ExportDefinition export, Boolean isSharedPart)\r\n   at System.ComponentModel.Composition.Hosting.CatalogExportProvider.CatalogExport.GetExportedValueCore()\r\n   at System.ComponentModel.Composition.Primitives.Export.get_Value()\r\n   at System.ComponentModel.Composition.ExportServices.GetCastedExportedValue[T](Export export)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tSystem.Collections.Generic.IEnumerable(FeatureTests.On.DependencyInjection.TestTypes.IGenericService(FeatureTests.On.DependencyInjection.TestTypes.IndependentService))\n\tRequiredTypeIdentity\tSystem.Collections.Generic.IEnumerable(FeatureTests.On.DependencyInjection.TestTypes.IGenericService(FeatureTests.On.DependencyInjection.TestTypes.IndependentService))\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tSystem.Collections.Generic.IEnumerable(FeatureTests.On.DependencyInjection.TestTypes.IGenericService(FeatureTests.On.DependencyInjection.TestTypes.IndependentService))\n\tRequiredTypeIdentity\tSystem.Collections.Generic.IEnumerable(FeatureTests.On.DependencyInjection.TestTypes.IGenericService(FeatureTests.On.DependencyInjection.TestTypes.IndependentService))\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency()\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency()\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency()\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency()\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tSystem.Lazy(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency)\n\tRequiredTypeIdentity\tSystem.Lazy(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tSystem.Lazy(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency)\n\tRequiredTypeIdentity\tSystem.Lazy(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if MEF provides PerRequest lifetime out of the box.\r\n",
        "error": "System.NotSupportedException: I am not sure if MEF provides PerRequest lifetime out of the box.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n",
        "error": "System.ComponentModel.Composition.ImportCardinalityMismatchException: No exports were found that match the constraint: \n\tContractName\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\n\tRequiredTypeIdentity\tFeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExports(ImportDefinition definition, AtomicComposition atomicComposition)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportsCore(Type type, Type metadataViewType, String contractName, ImportCardinality cardinality)\r\n   at System.ComponentModel.Composition.Hosting.ExportProvider.GetExportedValueCore[T](String contractName, ImportCardinality cardinality)\r\n   at lambda_method(Closure )\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "MicroSliver",
    "url": "http://MicroSliver.CodePlex.Com",
    "version": "2.1.6.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver is unable to set values to primitive/value types in the constructor.\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver is unable to set values to primitive/value types in the constructor.\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver does not have a mapping for interface of type IList`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver does not have a mapping for interface of type IList`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver does not have a mapping for interface of type ICollection`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver does not have a mapping for interface of type ICollection`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver does not have a mapping for interface of type IEnumerable`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver does not have a mapping for interface of type IEnumerable`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver does not have a mapping for interface of type IReadOnlyCollection`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver does not have a mapping for interface of type IReadOnlyCollection`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver does not have a mapping for interface of type IReadOnlyList`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver does not have a mapping for interface of type IReadOnlyList`1. ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Generic.Dictionary`2.get_Item(TKey key)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   --- End of inner exception stack trace ---\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "OpenGenericTypes": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[1], 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]', on 'MicroSliver.IMap Map[TContract,TConcrete]()' violates the constraint of type 'TConcrete'. ---> System.Security.VerificationException: Method MicroSliver.IoC.Map: type argument 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]' violates the constraint of type parameter 'TConcrete'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n",
        "error": "System.ArgumentException: GenericArguments[1], 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]', on 'MicroSliver.IMap Map[TContract,TConcrete]()' violates the constraint of type 'TConcrete'. ---> System.Security.VerificationException: Method MicroSliver.IoC.Map: type argument 'FeatureTests.On.DependencyInjection.TestTypes.GenericService`1[T]' violates the constraint of type parameter 'TConcrete'.\r\n   at System.RuntimeMethodHandle.GetStubIfNeeded(RuntimeMethodHandleInternal method, RuntimeType declaringType, RuntimeType[] methodInstantiation)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.Reflection.RuntimeMethodInfo.MakeGenericMethod(Type[] methodInstantiation)\r\n"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.Exception: MicroSliver is unable to set values to primitive/value types in the constructor.\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n",
        "error": "System.Exception: MicroSliver is unable to set values to primitive/value types in the constructor.\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.<ProcessCtor>b__7(ParameterInfo p)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at MicroSliver.IoC.ProcessCtor(ICtorInfo ctorInfo)\r\n   at MicroSliver.IoC.Get(Type T)\r\n   at MicroSliver.IoC.GetByType(Type T)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n",
        "error": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "failure",
        "comment": "Xunit.Sdk.SameException: Assert.Same() Failure\r\nExpected: FeatureTests.On.DependencyInjection.TestTypes.IndependentService\r\nActual:   FeatureTests.On.DependencyInjection.TestTypes.IndependentService\r\n   at Xunit.Assert.Same(Object expected, Object actual)\r\n",
        "error": "Xunit.Sdk.SameException: Assert.Same() Failure\r\nExpected: FeatureTests.On.DependencyInjection.TestTypes.IndependentService\r\nActual:   FeatureTests.On.DependencyInjection.TestTypes.IndependentService\r\n   at Xunit.Assert.Same(Object expected, Object actual)\r\n"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "failure",
        "comment": "Xunit.Sdk.TrueException: Assert.True() Failure\r\n   at Xunit.Assert.True(Boolean condition)\r\n",
        "error": "Xunit.Sdk.TrueException: Assert.True() Failure\r\n   at Xunit.Assert.True(Boolean condition)\r\n"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n",
        "error": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: MicroSliver fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: MicroSliver fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "Mugen",
    "url": "http://mugeninjection.codeplex.com/",
    "version": "3.5.0.0",
    "supports": [
      "net20",
      "net30",
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp71",
      "wp80",
      "wp81",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IReadOnlyCollection{\"IService\"}\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IReadOnlyCollection{\"IService\"}\".\r\nThe activation path:\r\n1) Request of \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\" using the type binding from \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\",  to \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IReadOnlyCollection{\"IService\"}\" in parameter \"System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] services\" of constructor \"Void .ctor(System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService])\" declared in \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n",
        "error": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IReadOnlyCollection{\"IService\"}\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IReadOnlyCollection{\"IService\"}\".\r\nThe activation path:\r\n1) Request of \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\" using the type binding from \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\",  to \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IReadOnlyCollection{\"IService\"}\" in parameter \"System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] services\" of constructor \"Void .ctor(System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService])\" declared in \"ServiceWithListConstructorDependency{\"IReadOnlyCollection{\"IService\"}\"}\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IReadOnlyList{\"IService\"}\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IReadOnlyList{\"IService\"}\".\r\nThe activation path:\r\n1) Request of \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\" using the type binding from \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\",  to \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IReadOnlyList{\"IService\"}\" in parameter \"System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] services\" of constructor \"Void .ctor(System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService])\" declared in \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n",
        "error": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IReadOnlyList{\"IService\"}\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IReadOnlyList{\"IService\"}\".\r\nThe activation path:\r\n1) Request of \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\" using the type binding from \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\",  to \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IReadOnlyList{\"IService\"}\" in parameter \"System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] services\" of constructor \"Void .ctor(System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService])\" declared in \"ServiceWithListConstructorDependency{\"IReadOnlyList{\"IService\"}\"}\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.ResolveAll(IBindingContext bindingContext, Boolean useParentToResolve)\r\n   at MugenInjection.Core.Components.CollectionConverter.ConvertToCollection(Type collectionType, Type elementType, ActivatorDelegate createCollection, InvokeMethodDelegate`1 addMethod, Object value)\r\n   at MugenInjection.Core.Components.CollectionConverter.<>c__DisplayClass2.<TryConvertInternal>b__1(Object o)\r\n   at MugenInjection.Core.InjectorBase.Activate(Object value, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.ResolveAll(IBindingContext bindingContext, Boolean useParentToResolve)\r\n   at MugenInjection.Core.Components.CollectionConverter.ConvertToCollection(Type collectionType, Type elementType, ActivatorDelegate createCollection, InvokeMethodDelegate`1 addMethod, Object value)\r\n   at MugenInjection.Core.Components.CollectionConverter.<>c__DisplayClass2.<TryConvertInternal>b__1(Object o)\r\n   at MugenInjection.Core.InjectorBase.Activate(Object value, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "failure",
        "comment": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IService2\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IService2\".\r\nThe activation path:\r\n1) Request of \"ServiceWithTwoConstructorDependencies\" using the type binding from \"ServiceWithTwoConstructorDependencies\",  to \"ServiceWithTwoConstructorDependencies\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IService2\" in parameter \"FeatureTests.On.DependencyInjection.TestTypes.IService2 service2\" of constructor \"Void .ctor(FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection.TestTypes.IService2)\" declared in \"ServiceWithTwoConstructorDependencies\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.<Activate>b__d(IBindingContext context)\r\n   at MugenInjection.Core.Components.FactoryAndLazyConverter.FactoryResolve.Invoke(Object[] objects)\r\n   at _DynamicMethodMugenInjection_Func`2_[..](Func`2 , IService2 )\r\n",
        "error": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IService2\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IService2\".\r\nThe activation path:\r\n1) Request of \"ServiceWithTwoConstructorDependencies\" using the type binding from \"ServiceWithTwoConstructorDependencies\",  to \"ServiceWithTwoConstructorDependencies\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IService2\" in parameter \"FeatureTests.On.DependencyInjection.TestTypes.IService2 service2\" of constructor \"Void .ctor(FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection.TestTypes.IService2)\" declared in \"ServiceWithTwoConstructorDependencies\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameters(MethodBase methodBase, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Activate(ConstructorInfo constructorInfo)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.<Activate>b__d(IBindingContext context)\r\n   at MugenInjection.Core.Components.FactoryAndLazyConverter.FactoryResolve.Invoke(Object[] objects)\r\n   at _DynamicMethodMugenInjection_Func`2_[..](Func`2 , IService2 )\r\n"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IService\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IService\".\r\nThe activation path:\r\n1) Request of \"ServiceWithSimplePropertyDependency\" using the type binding from \"ServiceWithSimplePropertyDependency\",  to \"ServiceWithSimplePropertyDependency\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IService\" in parameter of property \"FeatureTests.On.DependencyInjection.TestTypes.IService Service\" declared in \"ServiceWithSimplePropertyDependency\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameter(MemberInfo memberInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Inject[T](Type targetType, T& target)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n",
        "error": "MugenInjection.Exceptions.BindingNotFoundException: No matching bindings are available for a type \"IService\", and the type is not self-bindable.\r\nMake sure that you specify the binding for \"IService\".\r\nThe activation path:\r\n1) Request of \"ServiceWithSimplePropertyDependency\" using the type binding from \"ServiceWithSimplePropertyDependency\",  to \"ServiceWithSimplePropertyDependency\" in \"TransientScopeLifecycle\" lifecycle.\t\r\n2) Injection of dependency \"IService\" in parameter of property \"FeatureTests.On.DependencyInjection.TestTypes.IService Service\" declared in \"ServiceWithSimplePropertyDependency\"  \t\r\n\r\n\r\n   at MugenInjection.Core.InjectorBase.TryResolve(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.GetParameter(MemberInfo memberInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Activators.ExpressionActivator.Inject[T](Type targetType, T& target)\r\n   at MugenInjection.Activators.ActivatorBase.Activate(ConstructorInfo constructorInfo, IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.TypeBinding.ResolveService(IBindingContext bindingContext)\r\n   at MugenInjection.Bindings.BindingBase.ResolveServiceInternal(IBindingContext bindingContext)\r\n   at MugenInjection.Scope.DefaultScopeLifecycleContext.ResolveCurrentService()\r\n   at MugenInjection.Scope.TransientScopeLifecycle.GetObjectFromScope()\r\n   at MugenInjection.Bindings.BindingBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.Core.Components.BindingActivatorComponent.Activate(IBinding binding, IBindingContext bindingContext)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBinding binding, IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.ActivateOneInstance(IBindingContext bindingContext, Func`2 converter)\r\n   at MugenInjection.Core.InjectorBase.Activate(IBindingContext bindingContext, ActivateType activateType, Boolean useParentForAll)\r\n   at MugenInjection.Core.InjectorBase.Resolve(IBindingContext bindingContext)\r\n   at MugenInjection.InjectorExtension.Get(IInjectorResolver injector, Type service, IInjectionParameter[] parameters)\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "failure",
        "comment": "Xunit.Sdk.TrueException: Assert.True() Failure\r\n   at Xunit.Assert.True(Boolean condition)\r\n",
        "error": "Xunit.Sdk.TrueException: Assert.True() Failure\r\n   at Xunit.Assert.True(Boolean condition)\r\n"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotSameException: Assert.NotSame() Failure\r\n   at Xunit.Assert.NotSame(Object expected, Object actual)\r\n",
        "error": "Xunit.Sdk.NotSameException: Assert.NotSame() Failure\r\n   at Xunit.Assert.NotSame(Object expected, Object actual)\r\n"
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n",
        "error": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "Munq",
    "url": "http://Munq.codeplex.com",
    "version": "3.0.4501.20364",
    "supports": [
      "MonoAndroid",
      "MonoTouch",
      "net11",
      "net20",
      "net30",
      "net35",
      "net35-cf",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp",
      "wp71",
      "wp80",
      "wp81",
      "wpa81",
      "sl20",
      "sl30",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[FeatureTests.On.DependencyInjection.TestTypes.IService[]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.IService[] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[FeatureTests.On.DependencyInjection.TestTypes.IService[]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.IService[] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Func`1[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Func`1[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Lazy`1[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve System.Lazy`1[FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimpleConstructorDependency] ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n",
        "error": "Xunit.Sdk.NotNullException: Assert.NotNull() Failure\r\n   at Xunit.Assert.NotNull(Object object)\r\n"
      },
      "PropertyDependencyIsOptional": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "skipped",
        "comment": "Skipped as Simple dependency (Property dependencies) is not supported by this library."
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n",
        "error": "System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors ---> System.Collections.Generic.KeyNotFoundException: Munq IocContainer failed to resolve FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService ---> System.Collections.Generic.KeyNotFoundException: The given key was not present in the dictionary.\r\n   at System.Collections.Concurrent.ConcurrentDictionary`2.get_Item(TKey key)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve[TType]()\r\n   at lambda_method(Closure , IDependencyResolver )\r\n   at Munq.Registration.GetInstance()\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   --- End of inner exception stack trace ---\r\n   at Munq.IocContainer.HandleUnResolved(Exception knfe, String name, Type type)\r\n   at Munq.IocContainer.Resolve(String name, Type type)\r\n   at Munq.IocContainer.Resolve(Type type)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: Munq fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: Munq fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "Ninject",
    "url": "http://www.ninject.org",
    "version": "3.2.0.0",
    "supports": [
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "wp",
      "wp71",
      "wp80",
      "wp81",
      "sl20",
      "sl30",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "success"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "Ninject.ActivationException: Error activating IReadOnlyCollection{IService}\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IReadOnlyCollection{IService} into parameter services of constructor of type ServiceWithListConstructorDependency{IReadOnlyCollection{IService}}\r\n  1) Request for ServiceWithListConstructorDependency{IReadOnlyCollection{IService}}\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IReadOnlyCollection{IService}.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Providers.StandardProvider.GetValue(IContext context, ITarget target)\r\n   at Ninject.Activation.Providers.StandardProvider.<>c__DisplayClass4.<Create>b__2(ITarget target)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n",
        "error": "Ninject.ActivationException: Error activating IReadOnlyCollection{IService}\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IReadOnlyCollection{IService} into parameter services of constructor of type ServiceWithListConstructorDependency{IReadOnlyCollection{IService}}\r\n  1) Request for ServiceWithListConstructorDependency{IReadOnlyCollection{IService}}\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IReadOnlyCollection{IService}.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Providers.StandardProvider.GetValue(IContext context, ITarget target)\r\n   at Ninject.Activation.Providers.StandardProvider.<>c__DisplayClass4.<Create>b__2(ITarget target)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "Ninject.ActivationException: Error activating IReadOnlyList{IService}\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IReadOnlyList{IService} into parameter services of constructor of type ServiceWithListConstructorDependency{IReadOnlyList{IService}}\r\n  1) Request for ServiceWithListConstructorDependency{IReadOnlyList{IService}}\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IReadOnlyList{IService}.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Providers.StandardProvider.GetValue(IContext context, ITarget target)\r\n   at Ninject.Activation.Providers.StandardProvider.<>c__DisplayClass4.<Create>b__2(ITarget target)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n",
        "error": "Ninject.ActivationException: Error activating IReadOnlyList{IService}\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IReadOnlyList{IService} into parameter services of constructor of type ServiceWithListConstructorDependency{IReadOnlyList{IService}}\r\n  1) Request for ServiceWithListConstructorDependency{IReadOnlyList{IService}}\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IReadOnlyList{IService}.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Providers.StandardProvider.GetValue(IContext context, ITarget target)\r\n   at Ninject.Activation.Providers.StandardProvider.<>c__DisplayClass4.<Create>b__2(ITarget target)\r\n   at System.Linq.Enumerable.WhereSelectArrayIterator`2.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "failure",
        "comment": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at Ninject.Activation.Providers.StandardProvider.GetImplementationType(Type service)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.<CastIterator>d__b1`1.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n",
        "error": "System.ArgumentException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type 'T'. ---> System.TypeLoadException: GenericArguments[0], 'FeatureTests.On.DependencyInjection.TestTypes.IndependentService', on 'FeatureTests.On.DependencyInjection.TestTypes.GenericServiceWithIService2Constraint`1[T]' violates the constraint of type parameter 'T'.\r\n   at System.RuntimeTypeHandle.Instantiate(RuntimeTypeHandle handle, IntPtr* pInst, Int32 numGenericArgs, ObjectHandleOnStack type)\r\n   at System.RuntimeTypeHandle.Instantiate(Type[] inst)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   --- End of inner exception stack trace ---\r\n   at System.RuntimeType.ValidateGenericArguments(MemberInfo definition, RuntimeType[] genericArguments, Exception e)\r\n   at System.RuntimeType.MakeGenericType(Type[] instantiation)\r\n   at Ninject.Activation.Providers.StandardProvider.GetImplementationType(Type service)\r\n   at Ninject.Activation.Providers.StandardProvider.Create(IContext context)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectListIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.<CastIterator>d__b1`1.MoveNext()\r\n   at System.Linq.Buffer`1..ctor(IEnumerable`1 source)\r\n   at System.Linq.Enumerable.ToArray[TSource](IEnumerable`1 source)\r\n"
      },
      "FactoryWithNoParameters": {
        "result": "concern",
        "comment": "Ninject supports this through Ninject.Extensions.Factory, but attempts to install it from NuGet clash with Castle version."
      },
      "FactoryWithParameter": {
        "result": "concern",
        "comment": "Ninject supports this through Ninject.Extensions.Factory, but attempts to install it from NuGet clash with Castle version."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "concern",
        "comment": "Ninject supports this through Ninject.Extensions.Factory, but attempts to install it from NuGet clash with Castle version."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "concern",
        "comment": "Ninject supports this through Ninject.Extensions.Factory, but attempts to install it from NuGet clash with Castle version."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n",
        "error": "System.MissingMemberException: The lazily-initialized type does not have a public, parameterless constructor.\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "Ninject.ActivationException: Error activating IService\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IService into property Service of type ServiceWithSimplePropertyDependency\r\n  1) Request for ServiceWithSimplePropertyDependency\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IService.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Strategies.PropertyInjectionStrategy.GetValue(IContext context, ITarget target, IEnumerable`1 allPropertyValues)\r\n   at Ninject.Activation.Strategies.PropertyInjectionStrategy.Activate(IContext context, InstanceReference reference)\r\n   at Ninject.Activation.Pipeline.<>c__DisplayClass2.<Activate>b__0(IActivationStrategy s)\r\n   at Ninject.Infrastructure.Language.ExtensionsForIEnumerableOfT.Map[T](IEnumerable`1 series, Action`1 action)\r\n   at Ninject.Activation.Pipeline.Activate(IContext context, InstanceReference reference)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n",
        "error": "Ninject.ActivationException: Error activating IService\r\nNo matching bindings are available, and the type is not self-bindable.\r\nActivation path:\r\n  2) Injection of dependency IService into property Service of type ServiceWithSimplePropertyDependency\r\n  1) Request for ServiceWithSimplePropertyDependency\r\n\r\nSuggestions:\r\n  1) Ensure that you have defined a binding for IService.\r\n  2) If the binding was defined in a module, ensure that the module has been loaded into the kernel.\r\n  3) Ensure you have not accidentally created more than one kernel.\r\n  4) If you are using constructor arguments, ensure that the parameter name matches the constructors parameter name.\r\n  5) If you are using automatic module loading, ensure the search path and filters are correct.\r\n\r\n   at Ninject.KernelBase.Resolve(IRequest request)\r\n   at Ninject.Planning.Targets.Target`1.GetValue(Type service, IContext parent)\r\n   at Ninject.Planning.Targets.Target`1.ResolveWithin(IContext parent)\r\n   at Ninject.Activation.Strategies.PropertyInjectionStrategy.GetValue(IContext context, ITarget target, IEnumerable`1 allPropertyValues)\r\n   at Ninject.Activation.Strategies.PropertyInjectionStrategy.Activate(IContext context, InstanceReference reference)\r\n   at Ninject.Activation.Pipeline.<>c__DisplayClass2.<Activate>b__0(IActivationStrategy s)\r\n   at Ninject.Infrastructure.Language.ExtensionsForIEnumerableOfT.Map[T](IEnumerable`1 series, Action`1 action)\r\n   at Ninject.Activation.Pipeline.Activate(IContext context, InstanceReference reference)\r\n   at Ninject.Activation.Context.ResolveInternal(Object scope)\r\n   at Ninject.Activation.Context.Resolve()\r\n   at Ninject.KernelBase.<>c__DisplayClass15.<Resolve>b__f(IBinding binding)\r\n   at System.Linq.Enumerable.WhereSelectEnumerableIterator`2.MoveNext()\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n   at Ninject.ResolutionExtensions.Get(IResolutionRoot root, Type service, IParameter[] parameters)\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "concern",
        "comment": "It is obvious Ninject supports this, but I can't figure this out in a reasonable time."
      },
      "NoReuseBetweenRequests": {
        "result": "concern",
        "comment": "It is obvious Ninject supports this, but I can't figure this out in a reasonable time."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "concern",
        "comment": "It is obvious Ninject supports this, but I can't figure this out in a reasonable time."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "success"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "Simple Injector",
    "url": "https://simpleinjector.org/",
    "version": "2.6.1.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81",
      "wpa81",
      "sl40",
      "sl50"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "failure",
        "comment": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<IService[]> threw an exception. The constructor of type ServiceWithListConstructorDependency<IService[]> contains the parameter of type IService[] with name 'services' that is not registered. Please ensure IService[] is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IService[]>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<IService[]> contains the parameter of type IService[] with name 'services' that is not registered. Please ensure IService[] is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IService[]>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n",
        "error": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<IService[]> threw an exception. The constructor of type ServiceWithListConstructorDependency<IService[]> contains the parameter of type IService[] with name 'services' that is not registered. Please ensure IService[] is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IService[]>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<IService[]> contains the parameter of type IService[] with name 'services' that is not registered. Please ensure IService[] is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IService[]>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n"
      },
      "List": {
        "result": "failure",
        "comment": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<IList<IService>> threw an exception. The constructor of type ServiceWithListConstructorDependency<IList<IService>> contains the parameter of type IList<IService> with name 'services' that is not registered. Please ensure IList<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IList<IService>>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<IList<IService>> contains the parameter of type IList<IService> with name 'services' that is not registered. Please ensure IList<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IList<IService>>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n",
        "error": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<IList<IService>> threw an exception. The constructor of type ServiceWithListConstructorDependency<IList<IService>> contains the parameter of type IList<IService> with name 'services' that is not registered. Please ensure IList<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IList<IService>>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<IList<IService>> contains the parameter of type IList<IService> with name 'services' that is not registered. Please ensure IList<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<IList<IService>>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<ICollection<IService>> threw an exception. The constructor of type ServiceWithListConstructorDependency<ICollection<IService>> contains the parameter of type ICollection<IService> with name 'services' that is not registered. Please ensure ICollection<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<ICollection<IService>>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<ICollection<IService>> contains the parameter of type ICollection<IService> with name 'services' that is not registered. Please ensure ICollection<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<ICollection<IService>>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n",
        "error": "SimpleInjector.ActivationException: The registered delegate for type ServiceWithListConstructorDependency<ICollection<IService>> threw an exception. The constructor of type ServiceWithListConstructorDependency<ICollection<IService>> contains the parameter of type ICollection<IService> with name 'services' that is not registered. Please ensure ICollection<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<ICollection<IService>>. ---> SimpleInjector.ActivationException: The constructor of type ServiceWithListConstructorDependency<ICollection<IService>> contains the parameter of type ICollection<IService> with name 'services' that is not registered. Please ensure ICollection<IService> is registered in the container, or change the constructor of ServiceWithListConstructorDependency<ICollection<IService>>.\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.GetInstanceProducerFor(ParameterInfo parameter)\r\n   at SimpleInjector.Advanced.DefaultConstructorInjectionBehavior.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.ContainerOptions.BuildParameterExpression(ParameterInfo parameter)\r\n   at SimpleInjector.Registration.BuildConstructorParameters(ConstructorInfo constructor)\r\n   at SimpleInjector.Registration.BuildNewExpression(Type serviceType, Type implementationType)\r\n   at SimpleInjector.Registration.BuildTransientExpression[TService,TImplementation]()\r\n   at SimpleInjector.Lifestyles.TransientLifestyle.TransientLifestyleRegistration`2.BuildExpression()\r\n   at SimpleInjector.Registration.BuildExpression(InstanceProducer producer)\r\n   at SimpleInjector.InstanceProducer.BuildExpressionInternal()\r\n   at System.Lazy`1.CreateValue()\r\n   at System.Lazy`1.LazyInitValue()\r\n   at System.Lazy`1.get_Value()\r\n   at SimpleInjector.InstanceProducer.BuildInstanceCreator()\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   --- End of inner exception stack trace ---\r\n   at SimpleInjector.InstanceProducer.GetInstance()\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n"
      },
      "Enumerable": {
        "result": "success",
        "comment": "\r\n            Simple Injector does support resolving `IEnumerable<T>`, but requires a single registration \r\n            using one of the RegisterAll methods to register all types at once, which is a different\r\n            strategy than the other frameworks use.\r\n        "
      },
      "IReadOnlyCollection": {
        "result": "success"
      },
      "IReadOnlyList": {
        "result": "success"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "concern",
        "comment": "\r\n            Simple Injector does support filtering based on generic type constraints, but in case of \r\n            registering a collection of open generic types, it only allows all elements to be registered at \r\n            once. Open generic collections can be registered using `RegisterAllOpenGeneric`.\r\n            See: http://bit.ly/14DQx7c.\r\n        "
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "SimpleInjector.ActivationException: No registration for type Func<ServiceWithSimpleConstructorDependency> could be found.\r\n   at SimpleInjector.Container.ThrowMissingInstanceProducerException(Type serviceType)\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n",
        "error": "SimpleInjector.ActivationException: No registration for type Func<ServiceWithSimpleConstructorDependency> could be found.\r\n   at SimpleInjector.Container.ThrowMissingInstanceProducerException(Type serviceType)\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "SimpleInjector.ActivationException: No registration for type Lazy<ServiceWithSimpleConstructorDependency> could be found and an implicit registration could not be made. For the container to be able to create Lazy<ServiceWithSimpleConstructorDependency>, it should contain exactly one public constructor, but it has 6.\r\n   at SimpleInjector.Container.ThrowNotConstructableException(Type concreteType)\r\n   at SimpleInjector.Container.ThrowMissingInstanceProducerException(Type serviceType)\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n",
        "error": "SimpleInjector.ActivationException: No registration for type Lazy<ServiceWithSimpleConstructorDependency> could be found and an implicit registration could not be made. For the container to be able to create Lazy<ServiceWithSimpleConstructorDependency>, it should contain exactly one public constructor, but it has 6.\r\n   at SimpleInjector.Container.ThrowNotConstructableException(Type concreteType)\r\n   at SimpleInjector.Container.ThrowMissingInstanceProducerException(Type serviceType)\r\n   at SimpleInjector.Container.GetInstance(Type serviceType)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "concern",
        "comment": "\r\n        Simple Injector does not inject properties out of the box, but this behavior \r\n        can be changed by replacing the `Container.Options.PropertySelectionBehavior`.\r\n        For more info see: https://bit.ly/1cmMxuS.\r\n    "
      },
      "PropertyDependencyIsOptional": {
        "result": "concern",
        "comment": "\r\n        Simple Injector does not inject properties out of the box, but this behavior \r\n        can be changed by replacing the `Container.Options.PropertySelectionBehavior`.\r\n        For more info see: https://bit.ly/1cmMxuS.\r\n    "
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "concern",
        "comment": "\r\n        Simple Injector does not inject properties out of the box, but this behavior \r\n        can be changed by replacing the `Container.Options.PropertySelectionBehavior`.\r\n        For more info see: https://bit.ly/1cmMxuS.\r\n    "
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "concern",
        "comment": "\r\n            Simple Injector does not allow resolving types with multiple constructors out of the box, but this \r\n            behavior can be changed by replacing the `Container.Options.ConstructorResolutionBehavior`.\r\n            For more info see: https://bit.ly/13WKdRT.\r\n        "
      },
      "RegistrationAtAnyStage": {
        "result": "failure",
        "comment": "System.InvalidOperationException: The container can't be changed after the first call to GetInstance, GetAllInstances and Verify.\r\n   at SimpleInjector.Container.ThrowWhenContainerIsLocked()\r\n   at SimpleInjector.Container.AddRegistration(Type serviceType, Registration registration)\r\n   at SimpleInjector.Container.Register(Type serviceType, Type implementationType, Lifestyle lifestyle, String serviceTypeParamName, String implementationTypeParamName)\r\n   at SimpleInjector.Container.Register(Type serviceType, Type implementationType, Lifestyle lifestyle)\r\n",
        "error": "System.InvalidOperationException: The container can't be changed after the first call to GetInstance, GetAllInstances and Verify.\r\n   at SimpleInjector.Container.ThrowWhenContainerIsLocked()\r\n   at SimpleInjector.Container.AddRegistration(Type serviceType, Registration registration)\r\n   at SimpleInjector.Container.Register(Type serviceType, Type implementationType, Lifestyle lifestyle, String serviceTypeParamName, String implementationTypeParamName)\r\n   at SimpleInjector.Container.Register(Type serviceType, Type implementationType, Lifestyle lifestyle)\r\n"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "skipped",
        "comment": "Skipped as IService[] (List/array dependencies) is not supported by this library."
      }
    }
  },
  {
    "name": "Spring.NET",
    "url": "http://www.springframework.net/",
    "version": "1.3.2.40943",
    "supports": [
      "net11",
      "net20",
      "net30",
      "net35",
      "net35-Client",
      "net40",
      "net40-Client",
      "net45",
      "net451"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "failure",
        "comment": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n",
        "error": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n",
        "error": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n",
        "error": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n",
        "error": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n",
        "error": "Spring.Objects.Factory.UnsatisfiedDependencyException: Error creating object with name 'FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])' : Unsatisfied dependency expressed through constructor argument with index 0 of type [System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] : No unique object of type [System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]]] is defined : Unsatisfied dependency of type [System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]: expected at least 1 matching object to wire the [services] parameter on the constructor of object [FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]] (FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]])]\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.GetConstructorInstantiationInfo(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.ConstructorResolver.AutowireConstructor(String objectName, RootObjectDefinition rod, ConstructorInfo[] chosenCtors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.AutowireConstructor(String name, RootObjectDefinition definition, ConstructorInfo[] ctors, Object[] explicitArgs)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.CreateObjectInstance(String objectName, RootObjectDefinition objectDefinition, Object[] arguments)\r\n   at Spring.Objects.Factory.Support.AbstractAutowireCapableObjectFactory.InstantiateObject(String name, RootObjectDefinition definition, Object[] arguments, Boolean allowEagerCaching, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.AbstractObjectFactory.GetObjectInternal(String name, Type requiredType, Object[] arguments, Boolean suppressConfigure)\r\n   at Spring.Objects.Factory.Support.DefaultListableObjectFactory.GetObjectsOfType(Type type, Boolean includePrototypes, Boolean includeFactoryObjects)\r\n   at Spring.Context.Support.AbstractApplicationContext.GetObjectsOfType(Type type)\r\n"
      },
      "OpenGenericTypes": {
        "result": "failure",
        "comment": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n",
        "error": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "failure",
        "comment": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n",
        "error": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n"
      },
      "FactoryWithParameter": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "BasicLazySupport": {
        "result": "failure",
        "comment": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n",
        "error": "System.InvalidOperationException: Sequence contains no elements\r\n   at System.Linq.Enumerable.Single[TSource](IEnumerable`1 source)\r\n"
      },
      "NotCreatingLazyPrematurely": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Lazy<TService>) is not supported by this library."
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "success"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "success"
      },
      "PerRequestSupport": {
        "result": "concern",
        "comment": "It seems possible (scope='request' in XML) but I have no clue how to implement it in code."
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as No parameters (Func<TService>) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n",
        "error": "Xunit.Sdk.EqualException: Assert.Equal() Failure\r\nPosition: First difference is at position 0\r\nExpected: Most resolvable\r\nActual:   Default\r\n   at Xunit.Assert.Equal[T](T expected, T actual, IEqualityComparer`1 comparer)\r\n   at Xunit.Assert.Equal[T](T expected, T actual)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "StructureMap",
    "url": "http://structuremap.github.io",
    "version": "3.1.4.0",
    "supports": [
      "net40",
      "net40-Client",
      "net45",
      "net451",
      "win",
      "win81"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success"
      },
      "List": {
        "result": "success"
      },
      "Collection": {
        "result": "failure",
        "comment": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'ICollection<IService>'\r\n\r\nThere is no configuration specified for ICollection<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of ICollection<IService>*)\r\n2.) ServiceWithListConstructorDependency<ICollection<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<ICollection<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<ICollection<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n",
        "error": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'ICollection<IService>'\r\n\r\nThere is no configuration specified for ICollection<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of ICollection<IService>*)\r\n2.) ServiceWithListConstructorDependency<ICollection<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<ICollection<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<ICollection<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n"
      },
      "Enumerable": {
        "result": "success"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'IReadOnlyCollection<IService>'\r\n\r\nThere is no configuration specified for IReadOnlyCollection<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of IReadOnlyCollection<IService>*)\r\n2.) ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n",
        "error": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'IReadOnlyCollection<IService>'\r\n\r\nThere is no configuration specified for IReadOnlyCollection<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of IReadOnlyCollection<IService>*)\r\n2.) ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<IReadOnlyCollection<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'IReadOnlyList<IService>'\r\n\r\nThere is no configuration specified for IReadOnlyList<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of IReadOnlyList<IService>*)\r\n2.) ServiceWithListConstructorDependency<IReadOnlyList<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<IReadOnlyList<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<IReadOnlyList<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n",
        "error": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'IReadOnlyList<IService>'\r\n\r\nThere is no configuration specified for IReadOnlyList<IService>\r\n\r\n1.) new ServiceWithListConstructorDependency`1(*Default of IReadOnlyList<IService>*)\r\n2.) ServiceWithListConstructorDependency<IReadOnlyList<IService>>\r\n3.) Instance of ServiceWithListConstructorDependency<IReadOnlyList<IService>>\r\n4.) Container.GetInstance(ServiceWithListConstructorDependency<IReadOnlyList<IService>>)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "success"
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "success"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "success"
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'FeatureTests.On.DependencyInjection.TestTypes.IService'\r\n\r\nThere is no configuration specified for FeatureTests.On.DependencyInjection.TestTypes.IService\r\n\r\n1.) new ServiceWithSimplePropertyDependency(){\r\n    Set IService Service = *Default of IService*\r\n}\r\n2.) FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n3.) Instance of FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n4.) Container.GetInstance(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n",
        "error": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'FeatureTests.On.DependencyInjection.TestTypes.IService'\r\n\r\nThere is no configuration specified for FeatureTests.On.DependencyInjection.TestTypes.IService\r\n\r\n1.) new ServiceWithSimplePropertyDependency(){\r\n    Set IService Service = *Default of IService*\r\n}\r\n2.) FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n3.) Instance of FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\r\n4.) Container.GetInstance(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "failure",
        "comment": "System.NotSupportedException: I am not sure if StructureMap provides PerRequest lifetime out of the box.\r\n",
        "error": "System.NotSupportedException: I am not sure if StructureMap provides PerRequest lifetime out of the box.\r\n"
      },
      "ReuseWithinRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "NoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "skipped",
        "comment": "Skipped as Basic support (Request lifetime) is not supported by this library."
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService'\r\n\r\nThere is no configuration specified for FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService\r\n\r\n1.) new ServiceWithMultipleConstructors(*Default of IService*, *Default of IUnregisteredService*)\r\n2.) FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n3.) Instance of FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n4.) Container.GetInstance(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n",
        "error": "StructureMap.StructureMapConfigurationException: No default Instance is registered and cannot be automatically determined for type 'FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService'\r\n\r\nThere is no configuration specified for FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService\r\n\r\n1.) new ServiceWithMultipleConstructors(*Default of IService*, *Default of IUnregisteredService*)\r\n2.) FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n3.) Instance of FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\r\n4.) Container.GetInstance(FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors)\r\n\r\n   at lambda_method(Closure , IBuildSession , IContext )\r\n   at StructureMap.Building.BuildPlan.Build(IBuildSession session, IContext context)\r\n   at StructureMap.BuildSession.BuildNewInSession(Type pluginType, Instance instance)\r\n   at StructureMap.Pipeline.NulloTransientCache.Get(Type pluginType, Instance instance, IBuildSession session)\r\n   at StructureMap.BuildSession.ResolveFromLifecycle(Type pluginType, Instance instance)\r\n   at StructureMap.SessionCache.GetObject(Type pluginType, Instance instance, ILifecycle lifecycle)\r\n   at StructureMap.SessionCache.GetDefault(Type pluginType, IPipelineGraph pipelineGraph)\r\n   at StructureMap.Container.GetInstance(Type pluginType)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "success"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "success"
      }
    }
  },
  {
    "name": "Unity",
    "url": "http://unity.codeplex.com",
    "version": "3.5.0.0",
    "supports": [
      "net45",
      "net451",
      "win",
      "win81",
      "wp80",
      "wp81"
    ],
    "features": {
      "IndependentService": {
        "result": "success"
      },
      "IndependentServiceRegisteredAsSelf": {
        "result": "success"
      },
      "SingletonLifetime": {
        "result": "success"
      },
      "TransientLifetime": {
        "result": "success"
      },
      "PrebuiltInstance": {
        "result": "success"
      },
      "ConstructorDependency": {
        "result": "success"
      },
      "ConstructorDependencyUsingInstance": {
        "result": "success"
      },
      "Array": {
        "result": "success",
        "comment": "Note: Unity requires named registrations for list resolution to work."
      },
      "List": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "Collection": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.ICollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.ICollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "Enumerable": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IEnumerable`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IEnumerable`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "IReadOnlyCollection": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IReadOnlyCollection`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IReadOnlyCollection`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "IReadOnlyList": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService]],(none)\r\n  Resolving parameter \"services\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithListConstructorDependency`1[[System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]], mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089]](System.Collections.Generic.IReadOnlyList`1[[FeatureTests.On.DependencyInjection.TestTypes.IService, FeatureTests.On.DependencyInjection, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null]] services)\r\n    Resolving System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService],(none)\r\n ---> System.InvalidOperationException: The current type, System.Collections.Generic.IReadOnlyList`1[FeatureTests.On.DependencyInjection.TestTypes.IService], is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "OpenGenericTypes": {
        "result": "success"
      },
      "ConstrainsForOpenGenerics": {
        "result": "skipped",
        "comment": "Skipped as IEnumerable<IService> (List/array dependencies) is not supported by this library."
      },
      "FactoryWithNoParameters": {
        "result": "success"
      },
      "FactoryWithParameter": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], is delegate and cannot be constructed. Unity only supports resolving Func<T> and Func<IEnumerable<T>> by default.\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies],(none)\r\n ---> System.InvalidOperationException: The current type, System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], is delegate and cannot be constructed. Unity only supports resolving Func<T> and Func<IEnumerable<T>> by default.\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructDelegate(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies]\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], is delegate and cannot be constructed. Unity only supports resolving Func<T> and Func<IEnumerable<T>> by default.\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies],(none)\r\n ---> System.InvalidOperationException: The current type, System.Func`2[FeatureTests.On.DependencyInjection.TestTypes.IService2,FeatureTests.On.DependencyInjection.TestTypes.ServiceWithTwoConstructorDependencies], is delegate and cannot be constructed. Unity only supports resolving Func<T> and Func<IEnumerable<T>> by default.\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructDelegate(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "FactoryWithParameterForSubdependency": {
        "result": "skipped",
        "comment": "Skipped as Parameter for dependency (Func<TService>) is not supported by this library."
      },
      "TransientFactoryUsedBySingletonStillCreatesTransient": {
        "result": "success"
      },
      "BasicLazySupport": {
        "result": "success"
      },
      "NotCreatingLazyPrematurely": {
        "result": "success"
      },
      "LazyanBeUsedToResolveCircularDepenendency": {
        "result": "success"
      },
      "PropertyDependency": {
        "result": "success"
      },
      "PropertyDependencyIsOptional": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, FeatureTests.On.DependencyInjection.TestTypes.IService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency,(none)\r\n  Resolving value for property ServiceWithSimplePropertyDependency.Service\r\n    Resolving FeatureTests.On.DependencyInjection.TestTypes.IService,(none)\r\n ---> System.InvalidOperationException: The current type, FeatureTests.On.DependencyInjection.TestTypes.IService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, FeatureTests.On.DependencyInjection.TestTypes.IService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithSimplePropertyDependency,(none)\r\n  Resolving value for property ServiceWithSimplePropertyDependency.Service\r\n    Resolving FeatureTests.On.DependencyInjection.TestTypes.IService,(none)\r\n ---> System.InvalidOperationException: The current type, FeatureTests.On.DependencyInjection.TestTypes.IService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "PropertyDependencyDoesNotNeedCustomAttribute": {
        "result": "failure",
        "comment": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n",
        "error": "Xunit.Sdk.EmptyException: Assert.Empty() failure\r\n   at Xunit.Assert.Empty(IEnumerable collection)\r\n"
      },
      "PerRequestSupport": {
        "result": "success"
      },
      "ReuseWithinRequest": {
        "result": "success"
      },
      "NoReuseBetweenRequests": {
        "result": "success"
      },
      "ComponentIsDisposedAtTheEndOfRequest": {
        "result": "success"
      },
      "FactoryNoReuseBetweenRequests": {
        "result": "success"
      },
      "ReasonableConstructorSelection": {
        "result": "failure",
        "comment": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors,(none)\r\n  Resolving parameter \"service2\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors(FeatureTests.On.DependencyInjection.TestTypes.IService service1, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService service2)\r\n    Resolving FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService,(none)\r\n ---> System.InvalidOperationException: The current type, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n",
        "error": "Microsoft.Practices.Unity.ResolutionFailedException: Resolution of the dependency failed, type = \"FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors\", name = \"(none)\".\r\nException occurred while: while resolving.\r\nException is: InvalidOperationException - The current type, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n-----------------------------------------------\r\nAt the time of the exception, the container was:\r\n\r\n  Resolving FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors,(none)\r\n  Resolving parameter \"service2\" of constructor FeatureTests.On.DependencyInjection.TestTypes.ServiceWithMultipleConstructors(FeatureTests.On.DependencyInjection.TestTypes.IService service1, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService service2)\r\n    Resolving FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService,(none)\r\n ---> System.InvalidOperationException: The current type, FeatureTests.On.DependencyInjection.TestTypes.IUnregisteredService, is an interface and cannot be constructed. Are you missing a type mapping?\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodConstructorStrategy.ThrowForAttemptingToConstructInterface(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuilderContext.NewBuildUp(NamedTypeBuildKey newBuildKey)\r\n   at Microsoft.Practices.Unity.ObjectBuilder.NamedTypeDependencyResolverPolicy.Resolve(IBuilderContext context)\r\n   at lambda_method(Closure , IBuilderContext )\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicBuildPlanGenerationContext.<>c__DisplayClass1.<GetBuildMethod>b__0(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.DynamicMethodBuildPlan.BuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.BuildPlanStrategy.PreBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.ObjectBuilder2.StrategyChain.ExecuteBuildUp(IBuilderContext context)\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   --- End of inner exception stack trace ---\r\n   at Microsoft.Practices.Unity.UnityContainer.DoBuildUp(Type t, Object existing, String name, IEnumerable`1 resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainer.Resolve(Type t, String name, ResolverOverride[] resolverOverrides)\r\n   at Microsoft.Practices.Unity.UnityContainerExtensions.Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides)\r\n"
      },
      "RegistrationAtAnyStage": {
        "result": "success"
      },
      "GracefulRecursionHandling": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: Unity fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: Unity fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      },
      "GracefulRecursionHandlingForListDependency": {
        "result": "failure",
        "comment": "Xunit.Sdk.AssertException: Unity fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n",
        "error": "Xunit.Sdk.AssertException: Unity fails recursion for now, and we have no way to retest it in each run (without process crash).\r\n"
      }
    }
  }
]