@using System.Linq
@inherits DependencyInjection.FeatureTables.Generator.Outputs.Html.HtmlTemplateBase<System.Collections.Generic.IEnumerable<DependencyInjection.FeatureTables.Generator.Data.FeatureTable>>

<!DOCTYPE html>
@* Metanote: Ignore the following note in Razor template, it is only relevant to the result. *@
<!-- Note: This file has been generated by TableGenerator and should not be edited manually. -->
<html>
  <head>
    <title>Dependency Injection Feature Tests (.NET)</title>
    <link rel='stylesheet' href='FeatureTests.css' />
    
    <script type="text/javascript" src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
    <script type="text/javascript" src="js/jquery.toc.js"></script>
    <script type="text/javascript" src="js/jquery.sticky.js"></script>
  </head>
  <body>
    <header>
      <h1>Dependency Injection Feature Tests (.NET)</h1>
    </header>

    <div class="container">
      <nav class="toc"></nav>

      <div class="content">
        <section>
          <h2 id="GeneralInformation">General information</h2>
          <div class="section-description">
            <p>The goal of this project is to monitor support for important features across multiple dependency injection frameworks.</p>
            <p>You can find the code behind these tables in <a href="https://github.com/ashmind/net-di-frameworks">net-di-frameworks GitHub project</a>.</p>

            <p>Please note the following:</p>
            <ol>
              <li>The list of features is based on what I consider to be important. It is not an objective measure on which framework is "better".</li>
              <li>It is not possible to test for all features automatically. For example, extensibility is very important, but impossible to test/measure.</li>
              <li>The test results might not necessary be up to date (see the version for each framework).</li>
              <li>The test code should not be seen as best practice for each framework — it forces all of them to the same test interface.</li>
              <li>I am not an expert on all frameworks and not all adapters were reviewed by authors. So feature may fail because of incorrect adapter.</li>
            </ol>
            
            <p>Thanks for reading!</p>
          </div>
        </section>

        @foreach (var table in Model) {
          var tableLinkName = GenerateAnchor(table.DisplayName);
          
        <section>
          <h2 id="@tableLinkName">@table.DisplayName</h2>
          <div class="section-description">@FormatDescription(table.Description)</div>
        
          @{ var featuresWithDescription = table.Features.Where(f => !string.IsNullOrEmpty(f.Description)).ToArray(); }
          @if (featuresWithDescription.Any()) {
            <dl class="feature-descriptions">
              @foreach (var feature in featuresWithDescription) {
                <dt>@feature.Name</dt>
                <dd>@FormatDescription(feature.Description)</dd>
              }
            </dl>
          }

          <table>
            <tr>
              <th>Framework</th>
              @foreach (var feature in table.Features) {
                <th title="@feature.Name">@feature.Name</th>
              }
            </tr>
            
            @{ var comments = table.GetRows().SelectMany(r => r.Item2)
                                             .Where(c => c.HasComment)
                                             .Select(c => c.Comment)
                                             .GroupBy(c => c)
                                             .Select((g, index) => new { comment = g.Key, index = index + 1 })
                                             .ToList(); } 

            @foreach (var row in table.GetRows()) {
            <tr>
              <td class="framework-name">@row.Item1.FrameworkName</td>
              @foreach (var cell in row.Item2) {
                <td class="@(cell.State.ToString().ToLowerInvariant())">
                @if (cell.HasComment) {
                    var index = @comments.Single(x => x.comment == @cell.Comment).index;
                    <a class="local" href="#@tableLinkName-note-@index">@cell.DisplayText<sup>@index</sup></a>
                }
                else if (cell.DisplayUri != null) {
                    <a href="@cell.DisplayUri">@cell.DisplayText</a>
                }
                else {
                    @cell.DisplayText
                }
                </td>
              }
            </tr>
            }
          </table>
        
          <ol class="comments">
          @foreach (var x in comments) {
            <li id="@tableLinkName-note-@x.index">@FormatDescription(x.comment)</li>
          }
          </ol>
        </section>
        }
      
        <section>
          <h2 id="NotTested">Not tested</h2>
          <div class="section-description">
            <p>List of containers I couldn't test, with corresponding reasons.</p>
          </div>

          <dl class="not-tested">
            <dt>fFastInjector</dt>
            <dd>Static only: would require an AppDomain to test properly.</dd>
          
            <dt>Funq</dt>
            <dd>Not found on NuGet.</dd>
          
            <dt>Griffin</dt>
            <dd>Complex API. Please feel free to do a pull request for it.</dd>
          
            <dt>Hiro</dt>
            <dd>Complex API.</dd>
          
            <dt>LightInject</dt>
            <dd>Code-only NuGet package.</dd>
          
            <dt>Petite</dt>
            <dd>Code-only NuGet package.</dd>
          
            <dt>Speedioc</dt>
            <dd>I can't quickly figure out how to register an instance.</dd>
          
            <dt>Stiletto</dt>
            <dd>Seems to use attribute-only registration.</dd>
          
            <dt>TinyIoc</dt>
            <dd>Code-only NuGet package.</dd>
          </dl>
        </section>
      </div>
    </div>
    
    <script type="text/javascript">
      $('.toc').toc({ 
        selectors: 'h2,h3',
        anchorName: function(i, heading) {
            return heading.id;
        }
      }).sticky({ wrapperClassName: 'toc-wrapper', topSpacing: 20 });

      // cleanup: headers already have ids, but toc() is not smart enough
      $('h2').prev('span[id]').remove();
    </script>
  </body>
</html>